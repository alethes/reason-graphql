// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var $$String = require("bs-platform/lib/js/string.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function strOfTokenKind(param) {
  switch (param) {
    case 0 : 
        return "<SOF>";
    case 1 : 
        return "<EOF>";
    case 2 : 
        return "!";
    case 3 : 
    case 4 : 
        return "$";
    case 5 : 
        return "(";
    case 6 : 
        return ")";
    case 7 : 
        return "...";
    case 8 : 
        return ":";
    case 9 : 
        return "=";
    case 10 : 
        return "@";
    case 11 : 
        return "[";
    case 12 : 
        return "]";
    case 13 : 
        return "{";
    case 14 : 
        return "|";
    case 15 : 
        return "}";
    case 16 : 
        return "Name";
    case 17 : 
        return "Int";
    case 18 : 
        return "Float";
    case 19 : 
        return "String";
    case 20 : 
        return "Comment";
    
  }
}

function tok($staropt$star, $staropt$star$1, kind, start, end_, line, column) {
  var value = $staropt$star !== undefined ? $staropt$star : "";
  var prev = $staropt$star$1 !== undefined ? Js_primitive.valFromOption($staropt$star$1) : undefined;
  return /* record */Block.record([
            "kind",
            "location",
            "prev",
            "value"
          ], [
            kind,
            Block.record([
                "start",
                "end_",
                "line",
                "column"
              ], [
                start,
                end_,
                line,
                column
              ]),
            prev,
            value
          ]);
}

var $$SyntaxError = Caml_exceptions.create("Lexer-ReasonGraphqlServer.SyntaxError");

function printToken(token) {
  var kindStr = strOfTokenKind(token[/* kind */0]);
  var lineCol = "(" + (String(token[/* location */1][/* line */2]) + (":" + (String(token[/* location */1][/* column */3]) + ")")));
  var v = token[/* value */3];
  var tmp = v === "" ? " kind: '" + (kindStr + "'") : " kind: '" + (kindStr + ("', value: " + v));
  return lineCol + tmp;
}

function safeMatch(body, position, $$char) {
  if (position < body.length) {
    return Caml_string.get(body, position) === $$char;
  } else {
    return false;
  }
}

function positionAfterWhitespace(lexer, startPosition) {
  var body = lexer[/* body */0];
  var _position = startPosition;
  while(true) {
    var position = _position;
    if (position >= body.length) {
      return position;
    } else {
      var $$char = Caml_string.get(body, position);
      if ($$char === 65279) {
        return position + 1 | 0;
      } else {
        var switcher = $$char - 32 | 0;
        if (switcher > 12 || switcher < 0) {
          var switcher$1 = switcher + 23 | 0;
          if (switcher$1 > 4 || switcher$1 < 0) {
            return position;
          } else {
            switch (switcher$1) {
              case 0 : 
                  _position = position + 1 | 0;
                  continue ;
              case 1 : 
                  var newPosition = position + 1 | 0;
                  lexer[/* line */3] = lexer[/* line */3] + 1 | 0;
                  lexer[/* lineStart */4] = newPosition;
                  _position = newPosition;
                  continue ;
              case 2 : 
              case 3 : 
                  return position;
              case 4 : 
                  var match = safeMatch(body, position + 1 | 0, /* "\n" */10);
                  var newPosition$1 = match ? position + 2 | 0 : position + 1 | 0;
                  lexer[/* line */3] = lexer[/* line */3] + 1 | 0;
                  lexer[/* lineStart */4] = newPosition$1;
                  _position = newPosition$1;
                  continue ;
              
            }
          }
        } else if (switcher > 11 || switcher < 1) {
          _position = position + 1 | 0;
          continue ;
        } else {
          return position;
        }
      }
    }
  };
}

function isNameChar(param) {
  var switcher = param - 91 | 0;
  if (switcher > 5 || switcher < 0) {
    return (switcher + 26 >>> 0) <= 57;
  } else {
    return switcher === 4;
  }
}

function readName(body, start, line, column, prev) {
  var _position = start;
  while(true) {
    var position = _position;
    var match = Caml_string.get(body, position);
    var exit = 0;
    var switcher = match - 91 | 0;
    if (switcher > 5 || switcher < 0) {
      if ((switcher + 26 >>> 0) > 57) {
        exit = 1;
      } else {
        _position = position + 1 | 0;
        continue ;
      }
    } else if (switcher !== 4) {
      exit = 1;
    } else {
      _position = position + 1 | 0;
      continue ;
    }
    if (exit === 1) {
      return /* record */Block.record([
                "kind",
                "location",
                "prev",
                "value"
              ], [
                16,
                Block.record([
                    "start",
                    "end_",
                    "line",
                    "column"
                  ], [
                    start,
                    position,
                    line,
                    column
                  ]),
                prev,
                $$String.sub(body, start, position - start | 0)
              ]);
    }
    
  };
}

function readComment(body, start, line, column, prev) {
  var aux = function (_position) {
    while(true) {
      var position = _position;
      if (position > body.length) {
        return position;
      } else {
        var match = Caml_string.get(body, position);
        if (match !== 10 && match !== 13) {
          _position = position + 1 | 0;
          continue ;
        } else {
          return position;
        }
      }
    };
  };
  var position = aux(start);
  return /* record */Block.record([
            "kind",
            "location",
            "prev",
            "value"
          ], [
            20,
            Block.record([
                "start",
                "end_",
                "line",
                "column"
              ], [
                start,
                position,
                line,
                column
              ]),
            prev,
            $$String.sub(body, start, position - start | 0)
          ]);
}

function readDigits(body, startingPosition) {
  var body$1 = body;
  var _pos = startingPosition;
  while(true) {
    var pos = _pos;
    if (pos >= body$1.length) {
      return pos;
    } else {
      var c = Caml_string.get(body$1, pos);
      if (c > 57 || c < 48) {
        if (pos === startingPosition) {
          throw [
                $$SyntaxError,
                "Invalid number, expected digit but got: " + $$String.make(1, c)
              ];
        } else {
          return pos;
        }
      } else {
        _pos = pos + 1 | 0;
        continue ;
      }
    }
  };
}

function readNumber(body, start, line, column, prev) {
  var kind = /* INT */17;
  var position = start;
  if (Caml_string.get(body, start) === /* "-" */45) {
    position = position + 1 | 0;
  }
  if (Caml_string.get(body, position) === /* "0" */48) {
    position = position + 1 | 0;
    var $$char = Caml_string.get(body, position);
    if (!($$char > 57 || $$char < 48)) {
      throw [
            $$SyntaxError,
            "Invalid number, unexpected digit after 0: " + $$String.make(1, $$char)
          ];
    }
    
  } else {
    position = readDigits(body, position);
  }
  if (safeMatch(body, position, /* "." */46)) {
    kind = /* FLOAT */18;
    position = position + 1 | 0;
    position = readDigits(body, position);
  }
  if (safeMatch(body, position, /* "E" */69) || safeMatch(body, position, /* "e" */101)) {
    kind = /* FLOAT */18;
    position = position + 1 | 0;
    if (safeMatch(body, position, /* "+" */43) || safeMatch(body, position, /* "-" */45)) {
      position = position + 1 | 0;
    }
    position = readDigits(body, position);
  }
  return /* record */Block.record([
            "kind",
            "location",
            "prev",
            "value"
          ], [
            kind,
            Block.record([
                "start",
                "end_",
                "line",
                "column"
              ], [
                start,
                position,
                line,
                column
              ]),
            prev,
            $$String.sub(body, start, position - start | 0)
          ]);
}

function readString(_, _$1, _$2, _$3, _$4) {
  return Pervasives.failwith("Read String is Not Implemented");
}

function readToken(lexer, prevToken) {
  var body = lexer[/* body */0];
  var length = body.length;
  var position = positionAfterWhitespace(lexer, prevToken[/* location */1][/* end_ */1]);
  var line = lexer[/* line */3];
  var column = (1 + position | 0) - lexer[/* lineStart */4] | 0;
  var prev = prevToken;
  var location_001 = /* end_ */position + 1 | 0;
  var $$location = /* record */Block.record([
      "start",
      "end_",
      "line",
      "column"
    ], [
      position,
      location_001,
      line,
      column
    ]);
  if (position >= length) {
    return /* record */Block.record([
              "kind",
              "location",
              "prev",
              "value"
            ], [
              1,
              $$location,
              prevToken,
              ""
            ]);
  } else {
    var $$char = Caml_string.get(body, position);
    var exit = 0;
    var switcher = $$char - 33 | 0;
    if (switcher > 89 || switcher < 0) {
      var switcher$1 = switcher - 90 | 0;
      if (switcher$1 > 2 || switcher$1 < 0) {
        exit = 1;
      } else {
        switch (switcher$1) {
          case 0 : 
              return /* record */Block.record([
                        "kind",
                        "location",
                        "prev",
                        "value"
                      ], [
                        13,
                        $$location,
                        prev,
                        ""
                      ]);
          case 1 : 
              return /* record */Block.record([
                        "kind",
                        "location",
                        "prev",
                        "value"
                      ], [
                        14,
                        $$location,
                        prev,
                        ""
                      ]);
          case 2 : 
              return /* record */Block.record([
                        "kind",
                        "location",
                        "prev",
                        "value"
                      ], [
                        15,
                        $$location,
                        prev,
                        ""
                      ]);
          
        }
      }
    } else if (switcher >= 64) {
      exit = 2;
    } else {
      switch (switcher) {
        case 0 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      2,
                      $$location,
                      prev,
                      ""
                    ]);
        case 1 : 
            return Pervasives.failwith("Read String is Not Implemented");
        case 2 : 
            return readComment(body, position, line, column, prev);
        case 3 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      3,
                      $$location,
                      prev,
                      ""
                    ]);
        case 5 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      4,
                      $$location,
                      prev,
                      ""
                    ]);
        case 7 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      5,
                      $$location,
                      prev,
                      ""
                    ]);
        case 8 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      6,
                      $$location,
                      prev,
                      ""
                    ]);
        case 13 : 
            if (safeMatch(body, position + 1 | 0, /* "." */46) && safeMatch(body, position + 2 | 0, /* "." */46)) {
              return /* record */Block.record([
                        "kind",
                        "location",
                        "prev",
                        "value"
                      ], [
                        7,
                        Block.record([
                            "start",
                            "end_",
                            "line",
                            "column"
                          ], [
                            position,
                            position + 3 | 0,
                            line,
                            column
                          ]),
                        prev,
                        ""
                      ]);
            } else if ((position + 1 | 0) >= body.length) {
              throw [
                    $$SyntaxError,
                    "Unexpected End of File"
                  ];
            } else {
              throw [
                    $$SyntaxError,
                    "Unexpected Character" + $$String.make(1, Caml_string.get(body, position + 1 | 0))
                  ];
            }
        case 12 : 
        case 15 : 
        case 16 : 
        case 17 : 
        case 18 : 
        case 19 : 
        case 20 : 
        case 21 : 
        case 22 : 
        case 23 : 
        case 24 : 
            exit = 3;
            break;
        case 25 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      8,
                      $$location,
                      prev,
                      ""
                    ]);
        case 28 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      9,
                      $$location,
                      prev,
                      ""
                    ]);
        case 31 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      10,
                      $$location,
                      prev,
                      ""
                    ]);
        case 58 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      11,
                      $$location,
                      prev,
                      ""
                    ]);
        case 60 : 
            return /* record */Block.record([
                      "kind",
                      "location",
                      "prev",
                      "value"
                    ], [
                      12,
                      $$location,
                      prev,
                      ""
                    ]);
        case 32 : 
        case 33 : 
        case 34 : 
        case 35 : 
        case 36 : 
        case 37 : 
        case 38 : 
        case 39 : 
        case 40 : 
        case 41 : 
        case 42 : 
        case 43 : 
        case 44 : 
        case 45 : 
        case 46 : 
        case 47 : 
        case 48 : 
        case 49 : 
        case 50 : 
        case 51 : 
        case 52 : 
        case 53 : 
        case 54 : 
        case 55 : 
        case 56 : 
        case 57 : 
        case 62 : 
            exit = 2;
            break;
        case 4 : 
        case 6 : 
        case 9 : 
        case 10 : 
        case 11 : 
        case 14 : 
        case 26 : 
        case 27 : 
        case 29 : 
        case 30 : 
        case 59 : 
        case 61 : 
        case 63 : 
            exit = 1;
            break;
        
      }
    }
    switch (exit) {
      case 1 : 
          throw [
                $$SyntaxError,
                "Unexpected Character" + $$String.make(1, $$char)
              ];
      case 2 : 
          return readName(body, position, line, column, prev);
      case 3 : 
          return readNumber(body, position, line, column, prev);
      
    }
  }
}

var sof = tok(undefined, undefined, /* SOF */0, 0, 0, 1, 0);

function make(body) {
  return /* record */Block.record([
            "body",
            "lastToken",
            "token",
            "line",
            "lineStart"
          ], [
            body,
            sof,
            sof,
            1,
            0
          ]);
}

function lookahead(lexer) {
  var token = lexer[/* token */2];
  var match = token[/* kind */0];
  if (match !== 1) {
    var tok = readToken(lexer, token);
    while(tok[/* kind */0] === /* COMMENT */20) {
      tok = readToken(lexer, tok);
    };
    return tok;
  } else {
    return token;
  }
}

function advance(lexer) {
  lexer[/* lastToken */1] = lexer[/* token */2];
  lexer[/* token */2] = lookahead(lexer);
  return lexer[/* token */2];
}

exports.strOfTokenKind = strOfTokenKind;
exports.tok = tok;
exports.$$SyntaxError = $$SyntaxError;
exports.printToken = printToken;
exports.safeMatch = safeMatch;
exports.positionAfterWhitespace = positionAfterWhitespace;
exports.isNameChar = isNameChar;
exports.readName = readName;
exports.readComment = readComment;
exports.readDigits = readDigits;
exports.readNumber = readNumber;
exports.readString = readString;
exports.readToken = readToken;
exports.sof = sof;
exports.make = make;
exports.lookahead = lookahead;
exports.advance = advance;
/* sof Not a pure module */
